// Code generated by kaitai-struct-compiler from a .ksy source file. DO NOT EDIT.

import (
	"github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"
	"bytes"
	"io"
	"golang.org/x/text/encoding/unicode"
)


/**
 * This is a relational database format designed to be efficiently used
 * by very low power devices (there were deployments on 16 bit devices
 * with 32K of RAM). Today you are most likely to encounter it within
 * the Pioneer Professional DJ ecosystem, because it is the format that
 * their rekordbox software uses to write USB and SD media which can be
 * mounted in DJ controllers and used to play and mix music.
 * 
 * It has been reverse-engineered to facilitate sophisticated
 * integrations with light and laser shows, videos, and other musical
 * instruments, by supporting deep knowledge of what is playing and
 * what is coming next through monitoring the network communications of
 * the players.
 * 
 * The file is divided into fixed-size blocks. The first block has a
 * header that establishes the block size, and lists the tables
 * available in the database, identifying their types and the index of
 * the first of the series of linked pages that make up that table.
 * 
 * Each table is made up of a series of rows which may be spread across
 * any number of pages. The pages start with a header describing the
 * page and linking to the next page. The rest of the page is used as a
 * heap: rows are scattered around it, and located using an index
 * structure that builds backwards from the end of the page. Each row
 * of a given type has a fixed size structure which links to any
 * variable-sized strings by their offsets within the page.
 * 
 * As changes are made to the table, some records may become unused,
 * and there may be gaps within the heap that are too small to be used
 * by other data. There is a bit map in the row index that identifies
 * which rows are actually present. Rows that are not present must be
 * ignored: they do not contain valid (or even necessarily well-formed)
 * data.
 * 
 * The majority of the work in reverse-engineering this format was
 * performed by @henrybetts and @flesniak, for which I am hugely
 * grateful. @GreyCat helped me learn the intricacies (and best
 * practices) of Kaitai far faster than I would have managed on my own.
 * @see <a href="https://github.com/Deep-Symmetry/crate-digger/blob/master/doc/Analysis.pdf">Source</a>
 */

type RekordboxPdb_PageType int
const (
	RekordboxPdb_PageType__Tracks RekordboxPdb_PageType = 0
	RekordboxPdb_PageType__Genres RekordboxPdb_PageType = 1
	RekordboxPdb_PageType__Artists RekordboxPdb_PageType = 2
	RekordboxPdb_PageType__Albums RekordboxPdb_PageType = 3
	RekordboxPdb_PageType__Labels RekordboxPdb_PageType = 4
	RekordboxPdb_PageType__Keys RekordboxPdb_PageType = 5
	RekordboxPdb_PageType__Colors RekordboxPdb_PageType = 6
	RekordboxPdb_PageType__PlaylistTree RekordboxPdb_PageType = 7
	RekordboxPdb_PageType__PlaylistEntries RekordboxPdb_PageType = 8
	RekordboxPdb_PageType__Unknown9 RekordboxPdb_PageType = 9
	RekordboxPdb_PageType__Unknown10 RekordboxPdb_PageType = 10
	RekordboxPdb_PageType__HistoryPlaylists RekordboxPdb_PageType = 11
	RekordboxPdb_PageType__HistoryEntries RekordboxPdb_PageType = 12
	RekordboxPdb_PageType__Artwork RekordboxPdb_PageType = 13
	RekordboxPdb_PageType__Unknown14 RekordboxPdb_PageType = 14
	RekordboxPdb_PageType__Unknown15 RekordboxPdb_PageType = 15
	RekordboxPdb_PageType__Columns RekordboxPdb_PageType = 16
	RekordboxPdb_PageType__Unknown17 RekordboxPdb_PageType = 17
	RekordboxPdb_PageType__Unknown18 RekordboxPdb_PageType = 18
	RekordboxPdb_PageType__History RekordboxPdb_PageType = 19
)

type RekordboxPdb_PageTypeExt int
const (
	RekordboxPdb_PageTypeExt__Unknown0 RekordboxPdb_PageTypeExt = 0
	RekordboxPdb_PageTypeExt__Unknown1 RekordboxPdb_PageTypeExt = 1
	RekordboxPdb_PageTypeExt__Unknown2 RekordboxPdb_PageTypeExt = 2
	RekordboxPdb_PageTypeExt__Tags RekordboxPdb_PageTypeExt = 3
	RekordboxPdb_PageTypeExt__TagTracks RekordboxPdb_PageTypeExt = 4
	RekordboxPdb_PageTypeExt__Unknown5 RekordboxPdb_PageTypeExt = 5
	RekordboxPdb_PageTypeExt__Unknown6 RekordboxPdb_PageTypeExt = 6
	RekordboxPdb_PageTypeExt__Unknown7 RekordboxPdb_PageTypeExt = 7
	RekordboxPdb_PageTypeExt__Unknown8 RekordboxPdb_PageTypeExt = 8
)
type RekordboxPdb struct {
	_unnamed0 uint32
	LenPage uint32
	NumTables uint32
	NextUnusedPage uint32
	_unnamed4 uint32
	Sequence uint32
	Gap []byte
	Tables []*RekordboxPdb_Table
	IsExt bool
	_io *kaitai.Stream
	_root *RekordboxPdb
	_parent interface{}
}
func NewRekordboxPdb(isExt bool) *RekordboxPdb {
	return &RekordboxPdb{
		IsExt: isExt,
	}
}

func (this *RekordboxPdb) Read(io *kaitai.Stream, parent interface{}, root *RekordboxPdb) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp1, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this._unnamed0 = tmp1
	tmp2, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.LenPage = uint32(tmp2)
	tmp3, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.NumTables = uint32(tmp3)
	tmp4, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.NextUnusedPage = uint32(tmp4)
	tmp5, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this._unnamed4 = tmp5
	tmp6, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Sequence = uint32(tmp6)
	tmp7, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp7 = tmp7
	this.Gap = tmp7
	if !(bytes.Equal(this.Gap, []uint8{0, 0, 0, 0})) {
		return kaitai.NewValidationNotEqualError([]uint8{0, 0, 0, 0}, this.Gap, this._io, "/seq/6")
	}
	for i := 0; i < int(this.NumTables); i++ {
		_ = i
		tmp8 := NewRekordboxPdb_Table()
		err = tmp8.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Tables = append(this.Tables, tmp8)
	}
	return err
}

/**
 * Unknown purpose, perhaps an unoriginal signature, seems to
 * always have the value 0.
 */

/**
 * The database page size, in bytes. Pages are referred to by
 * index, so this size is needed to calculate their offset, and
 * table pages have a row index structure which is built from the
 * end of the page backwards, so finding that also requires this
 * value.
 */

/**
 * Determines the number of table entries that are present. Each
 * table is a linked list of pages containing rows of a particular
 * type.
 */

/**
 * @flesniak said: "Not used as any `empty_candidate`, points
 * past the end of the file."
 */

/**
 * @flesniak said: "Always incremented by at least one,
 * sometimes by two or three."
 */

/**
 * Only exposed until
 * https://github.com/kaitai-io/kaitai_struct/issues/825 can be
 * fixed.
 */

/**
 * Describes and links to the tables present in the database.
 */

/**
 * A variable length string which can be stored in a variety of
 * different encodings.
 */
type RekordboxPdb_DeviceSqlString struct {
	LengthAndKind uint8
	Body interface{}
	_io *kaitai.Stream
	_root *RekordboxPdb
	_parent interface{}
}
func NewRekordboxPdb_DeviceSqlString() *RekordboxPdb_DeviceSqlString {
	return &RekordboxPdb_DeviceSqlString{
	}
}

func (this *RekordboxPdb_DeviceSqlString) Read(io *kaitai.Stream, parent interface{}, root *RekordboxPdb) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp9, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.LengthAndKind = tmp9
	switch (this.LengthAndKind) {
	case 64:
		tmp10 := NewRekordboxPdb_DeviceSqlLongAscii()
		err = tmp10.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp10
	case 144:
		tmp11 := NewRekordboxPdb_DeviceSqlLongUtf16le()
		err = tmp11.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp11
	default:
		tmp12 := NewRekordboxPdb_DeviceSqlShortAscii(this.LengthAndKind)
		err = tmp12.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp12
	}
	return err
}

/**
 * Mangled length of an ordinary ASCII string if odd, or a flag
 * indicating another encoding with a longer length value to
 * follow.
 */

/**
 * A row that holds a history playlist ID and name, linking to
 * the track IDs captured during a performance on the player.
 */
type RekordboxPdb_HistoryPlaylistRow struct {
	Id uint32
	Name *RekordboxPdb_DeviceSqlString
	_io *kaitai.Stream
	_root *RekordboxPdb
	_parent *RekordboxPdb_RowRef
}
func NewRekordboxPdb_HistoryPlaylistRow() *RekordboxPdb_HistoryPlaylistRow {
	return &RekordboxPdb_HistoryPlaylistRow{
	}
}

func (this *RekordboxPdb_HistoryPlaylistRow) Read(io *kaitai.Stream, parent *RekordboxPdb_RowRef, root *RekordboxPdb) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp13, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Id = uint32(tmp13)
	tmp14 := NewRekordboxPdb_DeviceSqlString()
	err = tmp14.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Name = tmp14
	return err
}

/**
 * The unique identifier by which this history playlist can
 * be requested.
 */

/**
 * The variable-length string naming the playlist.
 */

/**
 * A row that holds a playlist name, ID, indication of whether it
 * is an ordinary playlist or a folder of other playlists, a link
 * to its parent folder, and its sort order.
 */
type RekordboxPdb_PlaylistTreeRow struct {
	ParentId uint32
	_unnamed1 []byte
	SortOrder uint32
	Id uint32
	RawIsFolder uint32
	Name *RekordboxPdb_DeviceSqlString
	_io *kaitai.Stream
	_root *RekordboxPdb
	_parent *RekordboxPdb_RowRef
	_f_isFolder bool
	isFolder bool
}
func NewRekordboxPdb_PlaylistTreeRow() *RekordboxPdb_PlaylistTreeRow {
	return &RekordboxPdb_PlaylistTreeRow{
	}
}

func (this *RekordboxPdb_PlaylistTreeRow) Read(io *kaitai.Stream, parent *RekordboxPdb_RowRef, root *RekordboxPdb) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp15, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.ParentId = uint32(tmp15)
	tmp16, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp16 = tmp16
	this._unnamed1 = tmp16
	tmp17, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.SortOrder = uint32(tmp17)
	tmp18, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Id = uint32(tmp18)
	tmp19, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.RawIsFolder = uint32(tmp19)
	tmp20 := NewRekordboxPdb_DeviceSqlString()
	err = tmp20.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Name = tmp20
	return err
}
func (this *RekordboxPdb_PlaylistTreeRow) IsFolder() (v bool, err error) {
	if (this._f_isFolder) {
		return this.isFolder, nil
	}
	this.isFolder = bool(this.RawIsFolder != 0)
	this._f_isFolder = true
	return this.isFolder, nil
}

/**
 * The ID of the `playlist_tree_row` in which this one can be
 * found, or `0` if this playlist exists at the root level.
 */

/**
 * The order in which the entries of this playlist are sorted.
 */

/**
 * The unique identifier by which this playlist or folder can
 * be requested and linked from other rows.
 */

/**
 * Has a non-zero value if this is actually a folder rather
 * than a playlist.
 */

/**
 * The variable-length string naming the playlist.
 */

/**
 * A row that holds a color name and the associated ID.
 */
type RekordboxPdb_ColorRow struct {
	_unnamed0 []byte
	Id uint16
	_unnamed2 uint8
	Name *RekordboxPdb_DeviceSqlString
	_io *kaitai.Stream
	_root *RekordboxPdb
	_parent *RekordboxPdb_RowRef
}
func NewRekordboxPdb_ColorRow() *RekordboxPdb_ColorRow {
	return &RekordboxPdb_ColorRow{
	}
}

func (this *RekordboxPdb_ColorRow) Read(io *kaitai.Stream, parent *RekordboxPdb_RowRef, root *RekordboxPdb) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp21, err := this._io.ReadBytes(int(5))
	if err != nil {
		return err
	}
	tmp21 = tmp21
	this._unnamed0 = tmp21
	tmp22, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.Id = uint16(tmp22)
	tmp23, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this._unnamed2 = tmp23
	tmp24 := NewRekordboxPdb_DeviceSqlString()
	err = tmp24.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Name = tmp24
	return err
}

/**
 * The unique identifier by which this color can be requested
 * and linked from other rows (such as tracks).
 */

/**
 * The variable-length string naming the color.
 */

/**
 * An ASCII-encoded string up to 127 bytes long.
 */
type RekordboxPdb_DeviceSqlShortAscii struct {
	Text string
	LengthAndKind uint8
	_io *kaitai.Stream
	_root *RekordboxPdb
	_parent *RekordboxPdb_DeviceSqlString
	_f_length bool
	length int
}
func NewRekordboxPdb_DeviceSqlShortAscii(lengthAndKind uint8) *RekordboxPdb_DeviceSqlShortAscii {
	return &RekordboxPdb_DeviceSqlShortAscii{
		LengthAndKind: lengthAndKind,
	}
}

func (this *RekordboxPdb_DeviceSqlShortAscii) Read(io *kaitai.Stream, parent *RekordboxPdb_DeviceSqlString, root *RekordboxPdb) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp25, err := this.Length()
	if err != nil {
		return err
	}
	tmp26, err := this._io.ReadBytes(int((tmp25 - 1)))
	if err != nil {
		return err
	}
	tmp26 = tmp26
	this.Text = string(tmp26)
	return err
}

/**
 * the length extracted of the entire device_sql_short_ascii type
 */
func (this *RekordboxPdb_DeviceSqlShortAscii) Length() (v int, err error) {
	if (this._f_length) {
		return this.length, nil
	}
	this.length = int((this.LengthAndKind >> 1))
	this._f_length = true
	return this.length, nil
}

/**
 * The content of the string.
 */

/**
 * A row that holds an album name and ID.
 */
type RekordboxPdb_AlbumRow struct {
	_unnamed0 uint16
	IndexShift uint16
	_unnamed2 uint32
	ArtistId uint32
	Id uint32
	_unnamed5 uint32
	_unnamed6 uint8
	OfsName uint8
	_io *kaitai.Stream
	_root *RekordboxPdb
	_parent *RekordboxPdb_RowRef
	_f_name bool
	name *RekordboxPdb_DeviceSqlString
}
func NewRekordboxPdb_AlbumRow() *RekordboxPdb_AlbumRow {
	return &RekordboxPdb_AlbumRow{
	}
}

func (this *RekordboxPdb_AlbumRow) Read(io *kaitai.Stream, parent *RekordboxPdb_RowRef, root *RekordboxPdb) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp27, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this._unnamed0 = tmp27
	tmp28, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.IndexShift = uint16(tmp28)
	tmp29, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this._unnamed2 = tmp29
	tmp30, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.ArtistId = uint32(tmp30)
	tmp31, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Id = uint32(tmp31)
	tmp32, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this._unnamed5 = tmp32
	tmp33, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this._unnamed6 = tmp33
	tmp34, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.OfsName = tmp34
	return err
}

/**
 * The name of this album.
 */
func (this *RekordboxPdb_AlbumRow) Name() (v *RekordboxPdb_DeviceSqlString, err error) {
	if (this._f_name) {
		return this.name, nil
	}
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	tmp35, err := this._parent.RowBase()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64((tmp35 + this.OfsName)), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp36 := NewRekordboxPdb_DeviceSqlString()
	err = tmp36.Read(this._io, this, this._root)
	if err != nil {
		return nil, err
	}
	this.name = tmp36
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	this._f_name = true
	this._f_name = true
	return this.name, nil
}

/**
 * Some kind of magic word? Usually 0x80, 0x00.
 */

/**
 * TODO name from @flesniak, but what does it mean?
 */

/**
 * Identifies the artist associated with the album.
 */

/**
 * The unique identifier by which this album can be requested
 * and linked from other rows (such as tracks).
 */

/**
 * @flesniak says: "always 0x03, maybe an unindexed empty string"
 */

/**
 * The location of the variable-length name string, relative to
 * the start of this row.
 */

/**
 * A table page, consisting of a short header describing the
 * content of the page and linking to the next page, followed by a
 * heap in which row data is found. At the end of the page there is
 * an index which locates all rows present in the heap via their
 * offsets past the end of the page header.
 */
type RekordboxPdb_Page struct {
	Gap []byte
	PageIndex uint32
	Type RekordboxPdb_PageType
	TypeExt RekordboxPdb_PageTypeExt
	NextPage *RekordboxPdb_PageRef
	_unnamed5 uint32
	_unnamed6 []byte
	NumRowsSmall uint8
	_unnamed8 uint8
	_unnamed9 uint8
	PageFlags uint8
	FreeSize uint16
	UsedSize uint16
	_unnamed13 uint16
	NumRowsLarge uint16
	_unnamed15 uint16
	_unnamed16 uint16
	Heap []byte
	_io *kaitai.Stream
	_root *RekordboxPdb
	_parent *RekordboxPdb_PageRef
	_f_numRows bool
	numRows uint16
	_f_numRowGroups bool
	numRowGroups int
	_f_rowGroups bool
	rowGroups []*RekordboxPdb_RowGroup
	_f_heapPos bool
	heapPos int
	_f_isDataPage bool
	isDataPage bool
}
func NewRekordboxPdb_Page() *RekordboxPdb_Page {
	return &RekordboxPdb_Page{
	}
}

func (this *RekordboxPdb_Page) Read(io *kaitai.Stream, parent *RekordboxPdb_PageRef, root *RekordboxPdb) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp37, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp37 = tmp37
	this.Gap = tmp37
	if !(bytes.Equal(this.Gap, []uint8{0, 0, 0, 0})) {
		return kaitai.NewValidationNotEqualError([]uint8{0, 0, 0, 0}, this.Gap, this._io, "/types/page/seq/0")
	}
	tmp38, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.PageIndex = uint32(tmp38)
	if (!(this._root.IsExt)) {
		tmp39, err := this._io.ReadU4le()
		if err != nil {
			return err
		}
		this.Type = RekordboxPdb_PageType(tmp39)
	}
	if (this._root.IsExt) {
		tmp40, err := this._io.ReadU4le()
		if err != nil {
			return err
		}
		this.TypeExt = RekordboxPdb_PageTypeExt(tmp40)
	}
	tmp41 := NewRekordboxPdb_PageRef()
	err = tmp41.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.NextPage = tmp41
	tmp42, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this._unnamed5 = tmp42
	tmp43, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp43 = tmp43
	this._unnamed6 = tmp43
	tmp44, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.NumRowsSmall = tmp44
	tmp45, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this._unnamed8 = tmp45
	tmp46, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this._unnamed9 = tmp46
	tmp47, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.PageFlags = tmp47
	tmp48, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.FreeSize = uint16(tmp48)
	tmp49, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.UsedSize = uint16(tmp49)
	tmp50, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this._unnamed13 = tmp50
	tmp51, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.NumRowsLarge = uint16(tmp51)
	tmp52, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this._unnamed15 = tmp52
	tmp53, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this._unnamed16 = tmp53
	if (false) {
		tmp54, err := this._io.ReadBytesFull()
		if err != nil {
			return err
		}
		tmp54 = tmp54
		this.Heap = tmp54
	}
	return err
}

/**
 * The number of rows that have ever been allocated on this
 * page (controls the number of row groups there are, but some
 * entries in each group may not be marked as present in the
 * table due to deletion or updates).
 */
func (this *RekordboxPdb_Page) NumRows() (v uint16, err error) {
	if (this._f_numRows) {
		return this.numRows, nil
	}
	var tmp55 uint16;
	if ( ((this.NumRowsLarge > this.NumRowsSmall) && (this.NumRowsLarge != 8191)) ) {
		tmp55 = this.NumRowsLarge
	} else {
		tmp55 = this.NumRowsSmall
	}
	this.numRows = uint16(tmp55)
	this._f_numRows = true
	return this.numRows, nil
}

/**
 * The number of row groups that are present in the index. Each
 * group can hold up to sixteen rows, but `row_present_flags`
 * must be consulted to determine whether each is valid.
 */
func (this *RekordboxPdb_Page) NumRowGroups() (v int, err error) {
	if (this._f_numRowGroups) {
		return this.numRowGroups, nil
	}
	tmp56, err := this.NumRows()
	if err != nil {
		return 0, err
	}
	this.numRowGroups = int((((tmp56 - 1) / 16) + 1))
	this._f_numRowGroups = true
	return this.numRowGroups, nil
}

/**
 * The actual row groups making up the row index. Each group
 * can hold up to sixteen rows. Non-data pages do not have
 * actual rows, and attempting to parse them can crash.
 */
func (this *RekordboxPdb_Page) RowGroups() (v []*RekordboxPdb_RowGroup, err error) {
	if (this._f_rowGroups) {
		return this.rowGroups, nil
	}
	tmp57, err := this.IsDataPage()
	if err != nil {
		return nil, err
	}
	if (tmp57) {
		tmp58, err := this.NumRowGroups()
		if err != nil {
			return nil, err
		}
		for i := 0; i < int(tmp58); i++ {
			_ = i
			tmp59 := NewRekordboxPdb_RowGroup(i)
			err = tmp59.Read(this._io, this, this._root)
			if err != nil {
				return nil, err
			}
			this.rowGroups = append(this.rowGroups, tmp59)
		}
		this._f_rowGroups = true
	}
	this._f_rowGroups = true
	return this.rowGroups, nil
}
func (this *RekordboxPdb_Page) HeapPos() (v int, err error) {
	if (this._f_heapPos) {
		return this.heapPos, nil
	}
	tmp60, err := this._io.Pos()
	if err != nil {
		return 0, err
	}
	this.heapPos = int(tmp60)
	this._f_heapPos = true
	return this.heapPos, nil
}
func (this *RekordboxPdb_Page) IsDataPage() (v bool, err error) {
	if (this._f_isDataPage) {
		return this.isDataPage, nil
	}
	this.isDataPage = bool((this.PageFlags & 64) == 0)
	this._f_isDataPage = true
	return this.isDataPage, nil
}

/**
 * Only exposed until
 * https://github.com/kaitai-io/kaitai_struct/issues/825 can be
 * fixed.
 */

/**
 * Matches the index we used to look up the page, sanity check?
 */

/**
 * Identifies the type of information stored in the rows of this page.
 */

/**
 * Identifies the type of information stored in the rows of this page in an exportExt.pdb file.
 */

/**
 * Index of the next page containing this type of rows. Points past
 * the end of the file if there are no more.
 */

/**
 * @flesniak said: "sequence number (0->1: 8->13, 1->2: 22, 2->3: 27)"
 */

/**
 * Holds the value used for `num_rows` (see below) unless
 * `num_rows_large` is larger (but not equal to `0x1fff`). This
 * seems like some strange mechanism to deal with the fact that
 * lots of tiny entries, such as are found in the
 * `playlist_entries` table, are too big to count with a single
 * byte. But why not just always use `num_rows_large`, then?
 */

/**
 * @flesniak said: "a bitmask (1st track: 32)"
 */

/**
 * @flesniak said: "often 0, sometimes larger, esp. for pages
 * with high real_entry_count (e.g. 12 for 101 entries)"
 */

/**
 * @flesniak said: "strange pages: 0x44, 0x64; otherwise seen: 0x24, 0x34"
 */

/**
 * Unused space (in bytes) in the page heap, excluding the row
 * index at end of page.
 */

/**
 * The number of bytes that are in use in the page heap.
 */

/**
 * @flesniak said: "(0->1: 2)"
 */

/**
 * Holds the value used for `num_rows` (as described above)
 * when that is too large to fit into `num_rows_small`, and
 * that situation seems to be indicated when this value is
 * larger than `num_rows_small`, but not equal to `0x1fff`.
 * This seems like some strange mechanism to deal with the fact
 * that lots of tiny entries, such as are found in the
 * `playlist_entries` table, are too big to count with a single
 * byte. But why not just always use this value, then?
 */

/**
 * @flesniak said: "1004 for strange blocks, 0 otherwise"
 */

/**
 * @flesniak said: "always 0 except 1 for history pages, num
 * entries for strange pages?"
 */

/**
 * A row that associates a track and a tag (found only in exportExt.pdb files).
 */
type RekordboxPdb_TagTrackRow struct {
	_unnamed0 uint32
	TrackId uint32
	TagId uint32
	_unnamed3 uint32
	_io *kaitai.Stream
	_root *RekordboxPdb
	_parent *RekordboxPdb_RowRef
}
func NewRekordboxPdb_TagTrackRow() *RekordboxPdb_TagTrackRow {
	return &RekordboxPdb_TagTrackRow{
	}
}

func (this *RekordboxPdb_TagTrackRow) Read(io *kaitai.Stream, parent *RekordboxPdb_RowRef, root *RekordboxPdb) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp61, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this._unnamed0 = tmp61
	tmp62, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.TrackId = uint32(tmp62)
	tmp63, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.TagId = uint32(tmp63)
	tmp64, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this._unnamed3 = tmp64
	return err
}

/**
 * Seems to always be zero.
 */

/**
 * The ID of the track that has a tag assigned to it.
 */

/**
 * The ID of the tag that has been assigned to a track.
 */

/**
 * Seems to always be 0x03 0x00 0x00 0x00.
 */

/**
 * A group of row indices, which are built backwards from the end
 * of the page. Holds up to sixteen row offsets, along with a bit
 * mask that indicates whether each row is actually present in the
 * table.
 */
type RekordboxPdb_RowGroup struct {
	GroupIndex uint16
	_io *kaitai.Stream
	_root *RekordboxPdb
	_parent *RekordboxPdb_Page
	_f_base bool
	base int
	_f_rowPresentFlags bool
	rowPresentFlags uint16
	_f_rows bool
	rows []*RekordboxPdb_RowRef
}
func NewRekordboxPdb_RowGroup(groupIndex uint16) *RekordboxPdb_RowGroup {
	return &RekordboxPdb_RowGroup{
		GroupIndex: groupIndex,
	}
}

func (this *RekordboxPdb_RowGroup) Read(io *kaitai.Stream, parent *RekordboxPdb_Page, root *RekordboxPdb) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	return err
}

/**
 * The starting point of this group of row indices.
 */
func (this *RekordboxPdb_RowGroup) Base() (v int, err error) {
	if (this._f_base) {
		return this.base, nil
	}
	this.base = int((this._root.LenPage - (this.GroupIndex * 36)))
	this._f_base = true
	return this.base, nil
}

/**
 * Each bit specifies whether a particular row is present. The
 * low order bit corresponds to the first row in this index,
 * whose offset immediately precedes these flag bits. The
 * second bit corresponds to the row whose offset precedes
 * that, and so on.
 */
func (this *RekordboxPdb_RowGroup) RowPresentFlags() (v uint16, err error) {
	if (this._f_rowPresentFlags) {
		return this.rowPresentFlags, nil
	}
	_pos, err := this._io.Pos()
	if err != nil {
		return 0, err
	}
	tmp65, err := this.Base()
	if err != nil {
		return 0, err
	}
	_, err = this._io.Seek(int64((tmp65 - 4)), io.SeekStart)
	if err != nil {
		return 0, err
	}
	tmp66, err := this._io.ReadU2le()
	if err != nil {
		return 0, err
	}
	this.rowPresentFlags = tmp66
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return 0, err
	}
	this._f_rowPresentFlags = true
	this._f_rowPresentFlags = true
	return this.rowPresentFlags, nil
}

/**
 * The row offsets in this group.
 */
func (this *RekordboxPdb_RowGroup) Rows() (v []*RekordboxPdb_RowRef, err error) {
	if (this._f_rows) {
		return this.rows, nil
	}
	for i := 0; i < int(16); i++ {
		_ = i
		tmp67 := NewRekordboxPdb_RowRef(i)
		err = tmp67.Read(this._io, this, this._root)
		if err != nil {
			return nil, err
		}
		this.rows = append(this.rows, tmp67)
	}
	this._f_rows = true
	this._f_rows = true
	return this.rows, nil
}

/**
 * A row that holds a genre name and the associated ID.
 */
type RekordboxPdb_GenreRow struct {
	Id uint32
	Name *RekordboxPdb_DeviceSqlString
	_io *kaitai.Stream
	_root *RekordboxPdb
	_parent *RekordboxPdb_RowRef
}
func NewRekordboxPdb_GenreRow() *RekordboxPdb_GenreRow {
	return &RekordboxPdb_GenreRow{
	}
}

func (this *RekordboxPdb_GenreRow) Read(io *kaitai.Stream, parent *RekordboxPdb_RowRef, root *RekordboxPdb) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp68, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Id = uint32(tmp68)
	tmp69 := NewRekordboxPdb_DeviceSqlString()
	err = tmp69.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Name = tmp69
	return err
}

/**
 * The unique identifier by which this genre can be requested
 * and linked from other rows (such as tracks).
 */

/**
 * The variable-length string naming the genre.
 */

/**
 * A row that associates a track with a position in a history playlist.
 */
type RekordboxPdb_HistoryEntryRow struct {
	TrackId uint32
	PlaylistId uint32
	EntryIndex uint32
	_io *kaitai.Stream
	_root *RekordboxPdb
	_parent *RekordboxPdb_RowRef
}
func NewRekordboxPdb_HistoryEntryRow() *RekordboxPdb_HistoryEntryRow {
	return &RekordboxPdb_HistoryEntryRow{
	}
}

func (this *RekordboxPdb_HistoryEntryRow) Read(io *kaitai.Stream, parent *RekordboxPdb_RowRef, root *RekordboxPdb) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp70, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.TrackId = uint32(tmp70)
	tmp71, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.PlaylistId = uint32(tmp71)
	tmp72, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.EntryIndex = uint32(tmp72)
	return err
}

/**
 * The track found at this position in the playlist.
 */

/**
 * The history playlist to which this entry belongs.
 */

/**
 * The position within the playlist represented by this entry.
 */

/**
 * A row that holds the path to an album art image file and the
 * associated artwork ID.
 */
type RekordboxPdb_ArtworkRow struct {
	Id uint32
	Path *RekordboxPdb_DeviceSqlString
	_io *kaitai.Stream
	_root *RekordboxPdb
	_parent *RekordboxPdb_RowRef
}
func NewRekordboxPdb_ArtworkRow() *RekordboxPdb_ArtworkRow {
	return &RekordboxPdb_ArtworkRow{
	}
}

func (this *RekordboxPdb_ArtworkRow) Read(io *kaitai.Stream, parent *RekordboxPdb_RowRef, root *RekordboxPdb) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp73, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Id = uint32(tmp73)
	tmp74 := NewRekordboxPdb_DeviceSqlString()
	err = tmp74.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Path = tmp74
	return err
}

/**
 * The unique identifier by which this art can be requested
 * and linked from other rows (such as tracks).
 */

/**
 * The variable-length file path string at which the art file
 * can be found.
 */

/**
 * An ASCII-encoded string preceded by a two-byte length field in a four-byte header.
 */
type RekordboxPdb_DeviceSqlLongAscii struct {
	Length uint16
	_unnamed1 uint8
	Text string
	_io *kaitai.Stream
	_root *RekordboxPdb
	_parent *RekordboxPdb_DeviceSqlString
}
func NewRekordboxPdb_DeviceSqlLongAscii() *RekordboxPdb_DeviceSqlLongAscii {
	return &RekordboxPdb_DeviceSqlLongAscii{
	}
}

func (this *RekordboxPdb_DeviceSqlLongAscii) Read(io *kaitai.Stream, parent *RekordboxPdb_DeviceSqlString, root *RekordboxPdb) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp75, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.Length = uint16(tmp75)
	tmp76, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this._unnamed1 = tmp76
	tmp77, err := this._io.ReadBytes(int((this.Length - 4)))
	if err != nil {
		return err
	}
	tmp77 = tmp77
	this.Text = string(tmp77)
	return err
}

/**
 * Contains the length of the string in bytes.
 */

/**
 * The content of the string.
 */

/**
 * A row that holds an artist name and ID.
 */
type RekordboxPdb_ArtistRow struct {
	Subtype uint16
	IndexShift uint16
	Id uint32
	_unnamed3 uint8
	OfsNameNear uint8
	_io *kaitai.Stream
	_root *RekordboxPdb
	_parent *RekordboxPdb_RowRef
	_f_ofsNameFar bool
	ofsNameFar uint16
	_f_name bool
	name *RekordboxPdb_DeviceSqlString
}
func NewRekordboxPdb_ArtistRow() *RekordboxPdb_ArtistRow {
	return &RekordboxPdb_ArtistRow{
	}
}

func (this *RekordboxPdb_ArtistRow) Read(io *kaitai.Stream, parent *RekordboxPdb_RowRef, root *RekordboxPdb) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp78, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.Subtype = uint16(tmp78)
	tmp79, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.IndexShift = uint16(tmp79)
	tmp80, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Id = uint32(tmp80)
	tmp81, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this._unnamed3 = tmp81
	tmp82, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.OfsNameNear = tmp82
	return err
}

/**
 * For names that might be further than 0xff bytes from the
 * start of this row, this holds a two-byte offset, and is
 * signalled by the subtype value.
 */
func (this *RekordboxPdb_ArtistRow) OfsNameFar() (v uint16, err error) {
	if (this._f_ofsNameFar) {
		return this.ofsNameFar, nil
	}
	if (this.Subtype == 100) {
		_pos, err := this._io.Pos()
		if err != nil {
			return 0, err
		}
		tmp83, err := this._parent.RowBase()
		if err != nil {
			return 0, err
		}
		_, err = this._io.Seek(int64((tmp83 + 10)), io.SeekStart)
		if err != nil {
			return 0, err
		}
		tmp84, err := this._io.ReadU2le()
		if err != nil {
			return 0, err
		}
		this.ofsNameFar = tmp84
		_, err = this._io.Seek(_pos, io.SeekStart)
		if err != nil {
			return 0, err
		}
		this._f_ofsNameFar = true
	}
	this._f_ofsNameFar = true
	return this.ofsNameFar, nil
}

/**
 * The name of this artist.
 */
func (this *RekordboxPdb_ArtistRow) Name() (v *RekordboxPdb_DeviceSqlString, err error) {
	if (this._f_name) {
		return this.name, nil
	}
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	tmp85, err := this._parent.RowBase()
	if err != nil {
		return nil, err
	}
	var tmp86 uint16;
	if (this.Subtype == 100) {
		tmp87, err := this.OfsNameFar()
		if err != nil {
			return nil, err
		}
		tmp86 = tmp87
	} else {
		tmp86 = this.OfsNameNear
	}
	_, err = this._io.Seek(int64((tmp85 + tmp86)), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp88 := NewRekordboxPdb_DeviceSqlString()
	err = tmp88.Read(this._io, this, this._root)
	if err != nil {
		return nil, err
	}
	this.name = tmp88
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	this._f_name = true
	this._f_name = true
	return this.name, nil
}

/**
 * Usually 0x60, but 0x64 means we have a long name offset
 * embedded in the row.
 */

/**
 * TODO name from @flesniak, but what does it mean?
 */

/**
 * The unique identifier by which this artist can be requested
 * and linked from other rows (such as tracks).
 */

/**
 * @flesniak says: "always 0x03, maybe an unindexed empty string"
 */

/**
 * The location of the variable-length name string, relative to
 * the start of this row, unless subtype is 0x64.
 */

/**
 * A row that holds a tag name and its ID (found only in exportExt.pdb files).
 */
type RekordboxPdb_TagRow struct {
	_unnamed0 uint16
	TagIndex uint16
	_unnamed2 uint64
	Category uint32
	CategoryPos uint32
	Id uint32
	RawIsCategory uint32
	_unnamed7 uint16
	Flags uint8
	Name *RekordboxPdb_DeviceSqlString
	_unnamed10 uint8
	_io *kaitai.Stream
	_root *RekordboxPdb
	_parent *RekordboxPdb_RowRef
	_f_isCategory bool
	isCategory bool
}
func NewRekordboxPdb_TagRow() *RekordboxPdb_TagRow {
	return &RekordboxPdb_TagRow{
	}
}

func (this *RekordboxPdb_TagRow) Read(io *kaitai.Stream, parent *RekordboxPdb_RowRef, root *RekordboxPdb) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp89, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this._unnamed0 = tmp89
	tmp90, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.TagIndex = uint16(tmp90)
	tmp91, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this._unnamed2 = tmp91
	tmp92, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Category = uint32(tmp92)
	tmp93, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.CategoryPos = uint32(tmp93)
	tmp94, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Id = uint32(tmp94)
	tmp95, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.RawIsCategory = uint32(tmp95)
	tmp96, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this._unnamed7 = tmp96
	tmp97, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Flags = tmp97
	tmp98 := NewRekordboxPdb_DeviceSqlString()
	err = tmp98.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Name = tmp98
	tmp99, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this._unnamed10 = tmp99
	return err
}

/**
 * Indicates whether this row stores a tag category instead of a tag.
 */
func (this *RekordboxPdb_TagRow) IsCategory() (v bool, err error) {
	if (this._f_isCategory) {
		return this.isCategory, nil
	}
	this.isCategory = bool(this.RawIsCategory != 0)
	this._f_isCategory = true
	return this.isCategory, nil
}

/**
 * Seems to always be 0x80, 0x06.
 */

/**
 * Increasing index for each row in multiples of 0x20.
 */

/**
 * Seems to always be zero.
 */

/**
 * The ID of the tag category this tag belongs to.
 * If this row represents a tag category, this field is zero.
 */

/**
 * The zero-based position of this tag in its category.
 * If this row represents a tag category, the zero-based position of the category itself in the category list.
 */

/**
 * The ID of this tag or tag category.
 * Referenced by tag_track_row if this row is a tag.
 */

/**
 * Non-zero when this row stores a tag category instead of a tag.
 */

/**
 * Seems to always be 0x03, 0x1f.
 */

/**
 * Maybe some kind of flags?
 */

/**
 * The name of the tag or tag category.
 */

/**
 * This seems to always be 0x03.
 */

/**
 * An index which points to a table page (its offset can be found
 * by multiplying the index by the `page_len` value in the file
 * header). This type allows the linked page to be lazy loaded.
 */
type RekordboxPdb_PageRef struct {
	Index uint32
	_io *kaitai.Stream
	_root *RekordboxPdb
	_parent interface{}
	_raw_body []byte
	_f_body bool
	body *RekordboxPdb_Page
}
func NewRekordboxPdb_PageRef() *RekordboxPdb_PageRef {
	return &RekordboxPdb_PageRef{
	}
}

func (this *RekordboxPdb_PageRef) Read(io *kaitai.Stream, parent interface{}, root *RekordboxPdb) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp100, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Index = uint32(tmp100)
	return err
}

/**
 * When referenced, loads the specified page and parses its
 * contents appropriately for the type of data it contains.
 */
func (this *RekordboxPdb_PageRef) Body() (v *RekordboxPdb_Page, err error) {
	if (this._f_body) {
		return this.body, nil
	}
	thisIo := this._root._io
	_pos, err := thisIo.Pos()
	if err != nil {
		return nil, err
	}
	_, err = thisIo.Seek(int64((this._root.LenPage * this.Index)), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp101, err := thisIo.ReadBytes(int(this._root.LenPage))
	if err != nil {
		return nil, err
	}
	tmp101 = tmp101
	this._raw_body = tmp101
	_io__raw_body := kaitai.NewStream(bytes.NewReader(this._raw_body))
	tmp102 := NewRekordboxPdb_Page()
	err = tmp102.Read(_io__raw_body, this, this._root)
	if err != nil {
		return nil, err
	}
	this.body = tmp102
	_, err = thisIo.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	this._f_body = true
	this._f_body = true
	return this.body, nil
}

/**
 * Identifies the desired page number.
 */

/**
 * A row that describes a track that can be played, with many
 * details about the music, and links to other tables like artists,
 * albums, keys, etc.
 */
type RekordboxPdb_TrackRow struct {
	_unnamed0 uint16
	IndexShift uint16
	Bitmask uint32
	SampleRate uint32
	ComposerId uint32
	FileSize uint32
	_unnamed6 uint32
	_unnamed7 uint16
	_unnamed8 uint16
	ArtworkId uint32
	KeyId uint32
	OriginalArtistId uint32
	LabelId uint32
	RemixerId uint32
	Bitrate uint32
	TrackNumber uint32
	Tempo uint32
	GenreId uint32
	AlbumId uint32
	ArtistId uint32
	Id uint32
	DiscNumber uint16
	PlayCount uint16
	Year uint16
	SampleDepth uint16
	Duration uint16
	_unnamed26 uint16
	ColorId uint8
	Rating uint8
	_unnamed29 uint16
	_unnamed30 uint16
	OfsStrings []uint16
	_io *kaitai.Stream
	_root *RekordboxPdb
	_parent *RekordboxPdb_RowRef
	_f_unknownString8 bool
	unknownString8 *RekordboxPdb_DeviceSqlString
	_f_unknownString6 bool
	unknownString6 *RekordboxPdb_DeviceSqlString
	_f_analyzeDate bool
	analyzeDate *RekordboxPdb_DeviceSqlString
	_f_filePath bool
	filePath *RekordboxPdb_DeviceSqlString
	_f_dateAdded bool
	dateAdded *RekordboxPdb_DeviceSqlString
	_f_unknownString3 bool
	unknownString3 *RekordboxPdb_DeviceSqlString
	_f_texter bool
	texter *RekordboxPdb_DeviceSqlString
	_f_kuvoPublic bool
	kuvoPublic *RekordboxPdb_DeviceSqlString
	_f_mixName bool
	mixName *RekordboxPdb_DeviceSqlString
	_f_unknownString5 bool
	unknownString5 *RekordboxPdb_DeviceSqlString
	_f_unknownString4 bool
	unknownString4 *RekordboxPdb_DeviceSqlString
	_f_message bool
	message *RekordboxPdb_DeviceSqlString
	_f_unknownString2 bool
	unknownString2 *RekordboxPdb_DeviceSqlString
	_f_isrc bool
	isrc *RekordboxPdb_DeviceSqlString
	_f_unknownString7 bool
	unknownString7 *RekordboxPdb_DeviceSqlString
	_f_filename bool
	filename *RekordboxPdb_DeviceSqlString
	_f_analyzePath bool
	analyzePath *RekordboxPdb_DeviceSqlString
	_f_comment bool
	comment *RekordboxPdb_DeviceSqlString
	_f_releaseDate bool
	releaseDate *RekordboxPdb_DeviceSqlString
	_f_autoloadHotCues bool
	autoloadHotCues *RekordboxPdb_DeviceSqlString
	_f_title bool
	title *RekordboxPdb_DeviceSqlString
}
func NewRekordboxPdb_TrackRow() *RekordboxPdb_TrackRow {
	return &RekordboxPdb_TrackRow{
	}
}

func (this *RekordboxPdb_TrackRow) Read(io *kaitai.Stream, parent *RekordboxPdb_RowRef, root *RekordboxPdb) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp103, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this._unnamed0 = tmp103
	tmp104, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.IndexShift = uint16(tmp104)
	tmp105, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Bitmask = uint32(tmp105)
	tmp106, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.SampleRate = uint32(tmp106)
	tmp107, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.ComposerId = uint32(tmp107)
	tmp108, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FileSize = uint32(tmp108)
	tmp109, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this._unnamed6 = tmp109
	tmp110, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this._unnamed7 = tmp110
	tmp111, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this._unnamed8 = tmp111
	tmp112, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.ArtworkId = uint32(tmp112)
	tmp113, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.KeyId = uint32(tmp113)
	tmp114, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.OriginalArtistId = uint32(tmp114)
	tmp115, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.LabelId = uint32(tmp115)
	tmp116, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.RemixerId = uint32(tmp116)
	tmp117, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Bitrate = uint32(tmp117)
	tmp118, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.TrackNumber = uint32(tmp118)
	tmp119, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Tempo = uint32(tmp119)
	tmp120, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.GenreId = uint32(tmp120)
	tmp121, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.AlbumId = uint32(tmp121)
	tmp122, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.ArtistId = uint32(tmp122)
	tmp123, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Id = uint32(tmp123)
	tmp124, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.DiscNumber = uint16(tmp124)
	tmp125, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.PlayCount = uint16(tmp125)
	tmp126, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.Year = uint16(tmp126)
	tmp127, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.SampleDepth = uint16(tmp127)
	tmp128, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.Duration = uint16(tmp128)
	tmp129, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this._unnamed26 = tmp129
	tmp130, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.ColorId = tmp130
	tmp131, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Rating = tmp131
	tmp132, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this._unnamed29 = tmp132
	tmp133, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this._unnamed30 = tmp133
	for i := 0; i < int(21); i++ {
		_ = i
		tmp134, err := this._io.ReadU2le()
		if err != nil {
			return err
		}
		this.OfsStrings = append(this.OfsStrings, tmp134)
	}
	return err
}

/**
 * A string of unknown purpose, usually empty.
 */
func (this *RekordboxPdb_TrackRow) UnknownString8() (v *RekordboxPdb_DeviceSqlString, err error) {
	if (this._f_unknownString8) {
		return this.unknownString8, nil
	}
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	tmp135, err := this._parent.RowBase()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64((tmp135 + this.OfsStrings[18])), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp136 := NewRekordboxPdb_DeviceSqlString()
	err = tmp136.Read(this._io, this, this._root)
	if err != nil {
		return nil, err
	}
	this.unknownString8 = tmp136
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	this._f_unknownString8 = true
	this._f_unknownString8 = true
	return this.unknownString8, nil
}

/**
 * A string of unknown purpose, usually empty.
 */
func (this *RekordboxPdb_TrackRow) UnknownString6() (v *RekordboxPdb_DeviceSqlString, err error) {
	if (this._f_unknownString6) {
		return this.unknownString6, nil
	}
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	tmp137, err := this._parent.RowBase()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64((tmp137 + this.OfsStrings[9])), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp138 := NewRekordboxPdb_DeviceSqlString()
	err = tmp138.Read(this._io, this, this._root)
	if err != nil {
		return nil, err
	}
	this.unknownString6 = tmp138
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	this._f_unknownString6 = true
	this._f_unknownString6 = true
	return this.unknownString6, nil
}

/**
 * A string containing the date this track was analyzed by rekordbox.
 */
func (this *RekordboxPdb_TrackRow) AnalyzeDate() (v *RekordboxPdb_DeviceSqlString, err error) {
	if (this._f_analyzeDate) {
		return this.analyzeDate, nil
	}
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	tmp139, err := this._parent.RowBase()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64((tmp139 + this.OfsStrings[15])), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp140 := NewRekordboxPdb_DeviceSqlString()
	err = tmp140.Read(this._io, this, this._root)
	if err != nil {
		return nil, err
	}
	this.analyzeDate = tmp140
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	this._f_analyzeDate = true
	this._f_analyzeDate = true
	return this.analyzeDate, nil
}

/**
 * The file path of the track audio file.
 */
func (this *RekordboxPdb_TrackRow) FilePath() (v *RekordboxPdb_DeviceSqlString, err error) {
	if (this._f_filePath) {
		return this.filePath, nil
	}
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	tmp141, err := this._parent.RowBase()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64((tmp141 + this.OfsStrings[20])), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp142 := NewRekordboxPdb_DeviceSqlString()
	err = tmp142.Read(this._io, this, this._root)
	if err != nil {
		return nil, err
	}
	this.filePath = tmp142
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	this._f_filePath = true
	this._f_filePath = true
	return this.filePath, nil
}

/**
 * A string containing the date this track was added to the collection.
 */
func (this *RekordboxPdb_TrackRow) DateAdded() (v *RekordboxPdb_DeviceSqlString, err error) {
	if (this._f_dateAdded) {
		return this.dateAdded, nil
	}
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	tmp143, err := this._parent.RowBase()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64((tmp143 + this.OfsStrings[10])), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp144 := NewRekordboxPdb_DeviceSqlString()
	err = tmp144.Read(this._io, this, this._root)
	if err != nil {
		return nil, err
	}
	this.dateAdded = tmp144
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	this._f_dateAdded = true
	this._f_dateAdded = true
	return this.dateAdded, nil
}

/**
 * A string of unknown purpose; @flesniak said "strange
 * strings, often zero length, sometimes low binary values
 * 0x01/0x02 as content"
 */
func (this *RekordboxPdb_TrackRow) UnknownString3() (v *RekordboxPdb_DeviceSqlString, err error) {
	if (this._f_unknownString3) {
		return this.unknownString3, nil
	}
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	tmp145, err := this._parent.RowBase()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64((tmp145 + this.OfsStrings[3])), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp146 := NewRekordboxPdb_DeviceSqlString()
	err = tmp146.Read(this._io, this, this._root)
	if err != nil {
		return nil, err
	}
	this.unknownString3 = tmp146
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	this._f_unknownString3 = true
	this._f_unknownString3 = true
	return this.unknownString3, nil
}

/**
 * A string of unknown purpose, which @flesniak named.
 */
func (this *RekordboxPdb_TrackRow) Texter() (v *RekordboxPdb_DeviceSqlString, err error) {
	if (this._f_texter) {
		return this.texter, nil
	}
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	tmp147, err := this._parent.RowBase()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64((tmp147 + this.OfsStrings[1])), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp148 := NewRekordboxPdb_DeviceSqlString()
	err = tmp148.Read(this._io, this, this._root)
	if err != nil {
		return nil, err
	}
	this.texter = tmp148
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	this._f_texter = true
	this._f_texter = true
	return this.texter, nil
}

/**
 * A string whose value is always either empty or "ON", and
 * which apparently for some insane reason is used, rather than
 * a single bit somewhere, to control whether the track
 * information is visible on Kuvo.
 */
func (this *RekordboxPdb_TrackRow) KuvoPublic() (v *RekordboxPdb_DeviceSqlString, err error) {
	if (this._f_kuvoPublic) {
		return this.kuvoPublic, nil
	}
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	tmp149, err := this._parent.RowBase()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64((tmp149 + this.OfsStrings[6])), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp150 := NewRekordboxPdb_DeviceSqlString()
	err = tmp150.Read(this._io, this, this._root)
	if err != nil {
		return nil, err
	}
	this.kuvoPublic = tmp150
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	this._f_kuvoPublic = true
	this._f_kuvoPublic = true
	return this.kuvoPublic, nil
}

/**
 * A string naming the remix of the track, if known.
 */
func (this *RekordboxPdb_TrackRow) MixName() (v *RekordboxPdb_DeviceSqlString, err error) {
	if (this._f_mixName) {
		return this.mixName, nil
	}
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	tmp151, err := this._parent.RowBase()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64((tmp151 + this.OfsStrings[12])), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp152 := NewRekordboxPdb_DeviceSqlString()
	err = tmp152.Read(this._io, this, this._root)
	if err != nil {
		return nil, err
	}
	this.mixName = tmp152
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	this._f_mixName = true
	this._f_mixName = true
	return this.mixName, nil
}

/**
 * A string of unknown purpose.
 */
func (this *RekordboxPdb_TrackRow) UnknownString5() (v *RekordboxPdb_DeviceSqlString, err error) {
	if (this._f_unknownString5) {
		return this.unknownString5, nil
	}
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	tmp153, err := this._parent.RowBase()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64((tmp153 + this.OfsStrings[8])), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp154 := NewRekordboxPdb_DeviceSqlString()
	err = tmp154.Read(this._io, this, this._root)
	if err != nil {
		return nil, err
	}
	this.unknownString5 = tmp154
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	this._f_unknownString5 = true
	this._f_unknownString5 = true
	return this.unknownString5, nil
}

/**
 * A string of unknown purpose; @flesniak said "strange
 * strings, often zero length, sometimes low binary values
 * 0x01/0x02 as content"
 */
func (this *RekordboxPdb_TrackRow) UnknownString4() (v *RekordboxPdb_DeviceSqlString, err error) {
	if (this._f_unknownString4) {
		return this.unknownString4, nil
	}
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	tmp155, err := this._parent.RowBase()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64((tmp155 + this.OfsStrings[4])), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp156 := NewRekordboxPdb_DeviceSqlString()
	err = tmp156.Read(this._io, this, this._root)
	if err != nil {
		return nil, err
	}
	this.unknownString4 = tmp156
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	this._f_unknownString4 = true
	this._f_unknownString4 = true
	return this.unknownString4, nil
}

/**
 * A string of unknown purpose, which @flesniak named.
 */
func (this *RekordboxPdb_TrackRow) Message() (v *RekordboxPdb_DeviceSqlString, err error) {
	if (this._f_message) {
		return this.message, nil
	}
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	tmp157, err := this._parent.RowBase()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64((tmp157 + this.OfsStrings[5])), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp158 := NewRekordboxPdb_DeviceSqlString()
	err = tmp158.Read(this._io, this, this._root)
	if err != nil {
		return nil, err
	}
	this.message = tmp158
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	this._f_message = true
	this._f_message = true
	return this.message, nil
}

/**
 * A string of unknown purpose; @flesniak said "thought
 * track number -> wrong!"
 */
func (this *RekordboxPdb_TrackRow) UnknownString2() (v *RekordboxPdb_DeviceSqlString, err error) {
	if (this._f_unknownString2) {
		return this.unknownString2, nil
	}
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	tmp159, err := this._parent.RowBase()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64((tmp159 + this.OfsStrings[2])), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp160 := NewRekordboxPdb_DeviceSqlString()
	err = tmp160.Read(this._io, this, this._root)
	if err != nil {
		return nil, err
	}
	this.unknownString2 = tmp160
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	this._f_unknownString2 = true
	this._f_unknownString2 = true
	return this.unknownString2, nil
}

/**
 * International Standard Recording Code of track
 * when known (in mangled format).
 */
func (this *RekordboxPdb_TrackRow) Isrc() (v *RekordboxPdb_DeviceSqlString, err error) {
	if (this._f_isrc) {
		return this.isrc, nil
	}
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	tmp161, err := this._parent.RowBase()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64((tmp161 + this.OfsStrings[0])), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp162 := NewRekordboxPdb_DeviceSqlString()
	err = tmp162.Read(this._io, this, this._root)
	if err != nil {
		return nil, err
	}
	this.isrc = tmp162
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	this._f_isrc = true
	this._f_isrc = true
	return this.isrc, nil
}

/**
 * A string of unknown purpose, usually empty.
 */
func (this *RekordboxPdb_TrackRow) UnknownString7() (v *RekordboxPdb_DeviceSqlString, err error) {
	if (this._f_unknownString7) {
		return this.unknownString7, nil
	}
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	tmp163, err := this._parent.RowBase()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64((tmp163 + this.OfsStrings[13])), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp164 := NewRekordboxPdb_DeviceSqlString()
	err = tmp164.Read(this._io, this, this._root)
	if err != nil {
		return nil, err
	}
	this.unknownString7 = tmp164
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	this._f_unknownString7 = true
	this._f_unknownString7 = true
	return this.unknownString7, nil
}

/**
 * The file name of the track audio file.
 */
func (this *RekordboxPdb_TrackRow) Filename() (v *RekordboxPdb_DeviceSqlString, err error) {
	if (this._f_filename) {
		return this.filename, nil
	}
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	tmp165, err := this._parent.RowBase()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64((tmp165 + this.OfsStrings[19])), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp166 := NewRekordboxPdb_DeviceSqlString()
	err = tmp166.Read(this._io, this, this._root)
	if err != nil {
		return nil, err
	}
	this.filename = tmp166
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	this._f_filename = true
	this._f_filename = true
	return this.filename, nil
}

/**
 * The file path of the track analysis, which allows rapid
 * seeking to particular times in variable bit-rate files,
 * jumping to particular beats, visual waveform previews, and
 * stores cue points and loops.
 */
func (this *RekordboxPdb_TrackRow) AnalyzePath() (v *RekordboxPdb_DeviceSqlString, err error) {
	if (this._f_analyzePath) {
		return this.analyzePath, nil
	}
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	tmp167, err := this._parent.RowBase()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64((tmp167 + this.OfsStrings[14])), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp168 := NewRekordboxPdb_DeviceSqlString()
	err = tmp168.Read(this._io, this, this._root)
	if err != nil {
		return nil, err
	}
	this.analyzePath = tmp168
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	this._f_analyzePath = true
	this._f_analyzePath = true
	return this.analyzePath, nil
}

/**
 * The comment assigned to the track by the DJ, if any.
 */
func (this *RekordboxPdb_TrackRow) Comment() (v *RekordboxPdb_DeviceSqlString, err error) {
	if (this._f_comment) {
		return this.comment, nil
	}
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	tmp169, err := this._parent.RowBase()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64((tmp169 + this.OfsStrings[16])), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp170 := NewRekordboxPdb_DeviceSqlString()
	err = tmp170.Read(this._io, this, this._root)
	if err != nil {
		return nil, err
	}
	this.comment = tmp170
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	this._f_comment = true
	this._f_comment = true
	return this.comment, nil
}

/**
 * A string containing the date this track was released, if known.
 */
func (this *RekordboxPdb_TrackRow) ReleaseDate() (v *RekordboxPdb_DeviceSqlString, err error) {
	if (this._f_releaseDate) {
		return this.releaseDate, nil
	}
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	tmp171, err := this._parent.RowBase()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64((tmp171 + this.OfsStrings[11])), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp172 := NewRekordboxPdb_DeviceSqlString()
	err = tmp172.Read(this._io, this, this._root)
	if err != nil {
		return nil, err
	}
	this.releaseDate = tmp172
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	this._f_releaseDate = true
	this._f_releaseDate = true
	return this.releaseDate, nil
}

/**
 * A string whose value is always either empty or "ON", and
 * which apparently for some insane reason is used, rather than
 * a single bit somewhere, to control whether hot-cues are
 * auto-loaded for the track.
 */
func (this *RekordboxPdb_TrackRow) AutoloadHotCues() (v *RekordboxPdb_DeviceSqlString, err error) {
	if (this._f_autoloadHotCues) {
		return this.autoloadHotCues, nil
	}
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	tmp173, err := this._parent.RowBase()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64((tmp173 + this.OfsStrings[7])), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp174 := NewRekordboxPdb_DeviceSqlString()
	err = tmp174.Read(this._io, this, this._root)
	if err != nil {
		return nil, err
	}
	this.autoloadHotCues = tmp174
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	this._f_autoloadHotCues = true
	this._f_autoloadHotCues = true
	return this.autoloadHotCues, nil
}

/**
 * The title of the track.
 */
func (this *RekordboxPdb_TrackRow) Title() (v *RekordboxPdb_DeviceSqlString, err error) {
	if (this._f_title) {
		return this.title, nil
	}
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	tmp175, err := this._parent.RowBase()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64((tmp175 + this.OfsStrings[17])), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp176 := NewRekordboxPdb_DeviceSqlString()
	err = tmp176.Read(this._io, this, this._root)
	if err != nil {
		return nil, err
	}
	this.title = tmp176
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	this._f_title = true
	this._f_title = true
	return this.title, nil
}

/**
 * Some kind of magic word? Usually 0x24, 0x00.
 */

/**
 * TODO name from @flesniak, but what does it mean?
 */

/**
 * TODO what do the bits mean?
 */

/**
 * Playback sample rate of the audio file.
 */

/**
 * References a row in the artist table if the composer is
 * known.
 */

/**
 * The length of the audio file, in bytes.
 */

/**
 * Some ID? Purpose as yet unknown.
 */

/**
 * From @flesniak: "always 19048?"
 */

/**
 * From @flesniak: "always 30967?"
 */

/**
 * References a row in the artwork table if there is album art.
 */

/**
 * References a row in the keys table if the track has a known
 * main musical key.
 */

/**
 * References a row in the artwork table if this is a cover
 * performance and the original artist is known.
 */

/**
 * References a row in the labels table if the track has a
 * known record label.
 */

/**
 * References a row in the artists table if the track has a
 * known remixer.
 */

/**
 * Playback bit rate of the audio file.
 */

/**
 * The position of the track within an album.
 */

/**
 * The tempo at the start of the track in beats per minute,
 * multiplied by 100.
 */

/**
 * References a row in the genres table if the track has a
 * known musical genre.
 */

/**
 * References a row in the albums table if the track has a
 * known album.
 */

/**
 * References a row in the artists table if the track has a
 * known performer.
 */

/**
 * The id by which this track can be looked up; players will
 * report this value in their status packets when they are
 * playing the track.
 */

/**
 * The number of the disc on which this track is found, if it
 * is known to be part of a multi-disc album.
 */

/**
 * The number of times this track has been played.
 */

/**
 * The year in which this track was released.
 */

/**
 * The number of bits per sample of the audio file.
 */

/**
 * The length, in seconds, of the track when played at normal
 * speed.
 */

/**
 * From @flesniak: "always 41?"
 */

/**
 * References a row in the colors table if the track has been
 * assigned a color.
 */

/**
 * The number of stars to display for the track, 0 to 5.
 */

/**
 * From @flesniak: "always 1?"
 */

/**
 * From @flesniak: "alternating 2 or 3"
 */

/**
 * The location, relative to the start of this row, of a
 * variety of variable-length strings.
 */

/**
 * A row that holds a musical key and the associated ID.
 */
type RekordboxPdb_KeyRow struct {
	Id uint32
	Id2 uint32
	Name *RekordboxPdb_DeviceSqlString
	_io *kaitai.Stream
	_root *RekordboxPdb
	_parent *RekordboxPdb_RowRef
}
func NewRekordboxPdb_KeyRow() *RekordboxPdb_KeyRow {
	return &RekordboxPdb_KeyRow{
	}
}

func (this *RekordboxPdb_KeyRow) Read(io *kaitai.Stream, parent *RekordboxPdb_RowRef, root *RekordboxPdb) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp177, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Id = uint32(tmp177)
	tmp178, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Id2 = uint32(tmp178)
	tmp179 := NewRekordboxPdb_DeviceSqlString()
	err = tmp179.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Name = tmp179
	return err
}

/**
 * The unique identifier by which this key can be requested
 * and linked from other rows (such as tracks).
 */

/**
 * Seems to be a second copy of the ID?
 */

/**
 * The variable-length string naming the key.
 */

/**
 * A row that associates a track with a position in a playlist.
 */
type RekordboxPdb_PlaylistEntryRow struct {
	EntryIndex uint32
	TrackId uint32
	PlaylistId uint32
	_io *kaitai.Stream
	_root *RekordboxPdb
	_parent *RekordboxPdb_RowRef
}
func NewRekordboxPdb_PlaylistEntryRow() *RekordboxPdb_PlaylistEntryRow {
	return &RekordboxPdb_PlaylistEntryRow{
	}
}

func (this *RekordboxPdb_PlaylistEntryRow) Read(io *kaitai.Stream, parent *RekordboxPdb_RowRef, root *RekordboxPdb) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp180, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.EntryIndex = uint32(tmp180)
	tmp181, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.TrackId = uint32(tmp181)
	tmp182, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.PlaylistId = uint32(tmp182)
	return err
}

/**
 * The position within the playlist represented by this entry.
 */

/**
 * The track found at this position in the playlist.
 */

/**
 * The playlist to which this entry belongs.
 */

/**
 * A row that holds a label name and the associated ID.
 */
type RekordboxPdb_LabelRow struct {
	Id uint32
	Name *RekordboxPdb_DeviceSqlString
	_io *kaitai.Stream
	_root *RekordboxPdb
	_parent *RekordboxPdb_RowRef
}
func NewRekordboxPdb_LabelRow() *RekordboxPdb_LabelRow {
	return &RekordboxPdb_LabelRow{
	}
}

func (this *RekordboxPdb_LabelRow) Read(io *kaitai.Stream, parent *RekordboxPdb_RowRef, root *RekordboxPdb) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp183, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Id = uint32(tmp183)
	tmp184 := NewRekordboxPdb_DeviceSqlString()
	err = tmp184.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Name = tmp184
	return err
}

/**
 * The unique identifier by which this label can be requested
 * and linked from other rows (such as tracks).
 */

/**
 * The variable-length string naming the label.
 */

/**
 * A UTF-16LE-encoded string preceded by a two-byte length field in a four-byte header.
 */
type RekordboxPdb_DeviceSqlLongUtf16le struct {
	Length uint16
	_unnamed1 uint8
	Text string
	_io *kaitai.Stream
	_root *RekordboxPdb
	_parent *RekordboxPdb_DeviceSqlString
}
func NewRekordboxPdb_DeviceSqlLongUtf16le() *RekordboxPdb_DeviceSqlLongUtf16le {
	return &RekordboxPdb_DeviceSqlLongUtf16le{
	}
}

func (this *RekordboxPdb_DeviceSqlLongUtf16le) Read(io *kaitai.Stream, parent *RekordboxPdb_DeviceSqlString, root *RekordboxPdb) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp185, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.Length = uint16(tmp185)
	tmp186, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this._unnamed1 = tmp186
	tmp187, err := this._io.ReadBytes(int((this.Length - 4)))
	if err != nil {
		return err
	}
	tmp187 = tmp187
	tmp188, err := kaitai.BytesToStr(tmp187, unicode.UTF16(unicode.LittleEndian, unicode.IgnoreBOM).NewDecoder())
	if err != nil {
		return err
	}
	this.Text = tmp188
	return err
}

/**
 * Contains the length of the string in bytes, plus four trailing bytes that must be ignored.
 */

/**
 * The content of the string.
 */

/**
 * Each table is a linked list of pages containing rows of a single
 * type. This header describes the nature of the table and links to
 * its pages by index.
 */
type RekordboxPdb_Table struct {
	Type RekordboxPdb_PageType
	TypeExt RekordboxPdb_PageTypeExt
	EmptyCandidate uint32
	FirstPage *RekordboxPdb_PageRef
	LastPage *RekordboxPdb_PageRef
	_io *kaitai.Stream
	_root *RekordboxPdb
	_parent *RekordboxPdb
}
func NewRekordboxPdb_Table() *RekordboxPdb_Table {
	return &RekordboxPdb_Table{
	}
}

func (this *RekordboxPdb_Table) Read(io *kaitai.Stream, parent *RekordboxPdb, root *RekordboxPdb) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	if (!(this._root.IsExt)) {
		tmp189, err := this._io.ReadU4le()
		if err != nil {
			return err
		}
		this.Type = RekordboxPdb_PageType(tmp189)
	}
	if (this._root.IsExt) {
		tmp190, err := this._io.ReadU4le()
		if err != nil {
			return err
		}
		this.TypeExt = RekordboxPdb_PageTypeExt(tmp190)
	}
	tmp191, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.EmptyCandidate = uint32(tmp191)
	tmp192 := NewRekordboxPdb_PageRef()
	err = tmp192.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.FirstPage = tmp192
	tmp193 := NewRekordboxPdb_PageRef()
	err = tmp193.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.LastPage = tmp193
	return err
}

/**
 * Identifies the kind of rows that are found in this table.
 */

/**
 * Identifies the kind of rows that are found in this table from an exportExt.pdb file.
 */

/**
 * Links to the chain of pages making up that table. The first
 * page seems to always contain similar garbage patterns and
 * zero rows, but the next page it links to contains the start
 * of the meaningful data rows.
 */

/**
 * Holds the index of the last page that makes up this table.
 * When following the linked list of pages of the table, you
 * either need to stop when you reach this page, or when you
 * notice that the `next_page` link you followed took you to a
 * page of a different `type`.
 */

/**
 * An offset which points to a row in the table, whose actual
 * presence is controlled by one of the bits in
 * `row_present_flags`. This instance allows the row itself to be
 * lazily loaded, unless it is not present, in which case there is
 * no content to be loaded.
 */
type RekordboxPdb_RowRef struct {
	RowIndex uint16
	_io *kaitai.Stream
	_root *RekordboxPdb
	_parent *RekordboxPdb_RowGroup
	_f_rowBase bool
	rowBase int
	_f_bodyExt bool
	bodyExt interface{}
	_f_body bool
	body interface{}
	_f_present bool
	present bool
	_f_ofsRow bool
	ofsRow uint16
}
func NewRekordboxPdb_RowRef(rowIndex uint16) *RekordboxPdb_RowRef {
	return &RekordboxPdb_RowRef{
		RowIndex: rowIndex,
	}
}

func (this *RekordboxPdb_RowRef) Read(io *kaitai.Stream, parent *RekordboxPdb_RowGroup, root *RekordboxPdb) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	return err
}

/**
 * The location of this row relative to the start of the page.
 * A variety of pointers (such as all device_sql_string values)
 * are calculated with respect to this position.
 */
func (this *RekordboxPdb_RowRef) RowBase() (v int, err error) {
	if (this._f_rowBase) {
		return this.rowBase, nil
	}
	tmp194, err := this.OfsRow()
	if err != nil {
		return 0, err
	}
	tmp195, err := this._parent._parent.HeapPos()
	if err != nil {
		return 0, err
	}
	this.rowBase = int((tmp194 + tmp195))
	this._f_rowBase = true
	return this.rowBase, nil
}

/**
 * The actual content of the row in an exportExt.pdb file, as long as it is present.
 */
func (this *RekordboxPdb_RowRef) BodyExt() (v interface{}, err error) {
	if (this._f_bodyExt) {
		return this.bodyExt, nil
	}
	tmp196, err := this.Present()
	if err != nil {
		return nil, err
	}
	if ( ((tmp196) && (this._root.IsExt)) ) {
		_pos, err := this._io.Pos()
		if err != nil {
			return nil, err
		}
		tmp197, err := this.RowBase()
		if err != nil {
			return nil, err
		}
		_, err = this._io.Seek(int64(tmp197), io.SeekStart)
		if err != nil {
			return nil, err
		}
		switch (this._parent._parent.TypeExt) {
		case RekordboxPdb_PageTypeExt__Tags:
			tmp198 := NewRekordboxPdb_TagRow()
			err = tmp198.Read(this._io, this, this._root)
			if err != nil {
				return nil, err
			}
			this.bodyExt = tmp198
		case RekordboxPdb_PageTypeExt__TagTracks:
			tmp199 := NewRekordboxPdb_TagTrackRow()
			err = tmp199.Read(this._io, this, this._root)
			if err != nil {
				return nil, err
			}
			this.bodyExt = tmp199
		}
		_, err = this._io.Seek(_pos, io.SeekStart)
		if err != nil {
			return nil, err
		}
		this._f_bodyExt = true
	}
	this._f_bodyExt = true
	return this.bodyExt, nil
}

/**
 * The actual content of the row, as long as it is present.
 */
func (this *RekordboxPdb_RowRef) Body() (v interface{}, err error) {
	if (this._f_body) {
		return this.body, nil
	}
	tmp200, err := this.Present()
	if err != nil {
		return nil, err
	}
	if ( ((tmp200) && (!(this._root.IsExt))) ) {
		_pos, err := this._io.Pos()
		if err != nil {
			return nil, err
		}
		tmp201, err := this.RowBase()
		if err != nil {
			return nil, err
		}
		_, err = this._io.Seek(int64(tmp201), io.SeekStart)
		if err != nil {
			return nil, err
		}
		switch (this._parent._parent.Type) {
		case RekordboxPdb_PageType__PlaylistTree:
			tmp202 := NewRekordboxPdb_PlaylistTreeRow()
			err = tmp202.Read(this._io, this, this._root)
			if err != nil {
				return nil, err
			}
			this.body = tmp202
		case RekordboxPdb_PageType__Keys:
			tmp203 := NewRekordboxPdb_KeyRow()
			err = tmp203.Read(this._io, this, this._root)
			if err != nil {
				return nil, err
			}
			this.body = tmp203
		case RekordboxPdb_PageType__Artists:
			tmp204 := NewRekordboxPdb_ArtistRow()
			err = tmp204.Read(this._io, this, this._root)
			if err != nil {
				return nil, err
			}
			this.body = tmp204
		case RekordboxPdb_PageType__Albums:
			tmp205 := NewRekordboxPdb_AlbumRow()
			err = tmp205.Read(this._io, this, this._root)
			if err != nil {
				return nil, err
			}
			this.body = tmp205
		case RekordboxPdb_PageType__Genres:
			tmp206 := NewRekordboxPdb_GenreRow()
			err = tmp206.Read(this._io, this, this._root)
			if err != nil {
				return nil, err
			}
			this.body = tmp206
		case RekordboxPdb_PageType__HistoryPlaylists:
			tmp207 := NewRekordboxPdb_HistoryPlaylistRow()
			err = tmp207.Read(this._io, this, this._root)
			if err != nil {
				return nil, err
			}
			this.body = tmp207
		case RekordboxPdb_PageType__Artwork:
			tmp208 := NewRekordboxPdb_ArtworkRow()
			err = tmp208.Read(this._io, this, this._root)
			if err != nil {
				return nil, err
			}
			this.body = tmp208
		case RekordboxPdb_PageType__PlaylistEntries:
			tmp209 := NewRekordboxPdb_PlaylistEntryRow()
			err = tmp209.Read(this._io, this, this._root)
			if err != nil {
				return nil, err
			}
			this.body = tmp209
		case RekordboxPdb_PageType__Labels:
			tmp210 := NewRekordboxPdb_LabelRow()
			err = tmp210.Read(this._io, this, this._root)
			if err != nil {
				return nil, err
			}
			this.body = tmp210
		case RekordboxPdb_PageType__Tracks:
			tmp211 := NewRekordboxPdb_TrackRow()
			err = tmp211.Read(this._io, this, this._root)
			if err != nil {
				return nil, err
			}
			this.body = tmp211
		case RekordboxPdb_PageType__HistoryEntries:
			tmp212 := NewRekordboxPdb_HistoryEntryRow()
			err = tmp212.Read(this._io, this, this._root)
			if err != nil {
				return nil, err
			}
			this.body = tmp212
		case RekordboxPdb_PageType__Colors:
			tmp213 := NewRekordboxPdb_ColorRow()
			err = tmp213.Read(this._io, this, this._root)
			if err != nil {
				return nil, err
			}
			this.body = tmp213
		}
		_, err = this._io.Seek(_pos, io.SeekStart)
		if err != nil {
			return nil, err
		}
		this._f_body = true
	}
	this._f_body = true
	return this.body, nil
}

/**
 * Indicates whether the row index considers this row to be
 * present in the table. Will be `false` if the row has been
 * deleted.
 */
func (this *RekordboxPdb_RowRef) Present() (v bool, err error) {
	if (this._f_present) {
		return this.present, nil
	}
	var tmp214 bool;
	tmp215, err := this._parent.RowPresentFlags()
	if err != nil {
		return false, err
	}
	if (((tmp215 >> this.RowIndex) & 1) != 0) {
		tmp214 = true
	} else {
		tmp214 = false
	}
	this.present = bool(tmp214)
	this._f_present = true
	return this.present, nil
}

/**
 * The offset of the start of the row (in bytes past the end of
 * the page header).
 */
func (this *RekordboxPdb_RowRef) OfsRow() (v uint16, err error) {
	if (this._f_ofsRow) {
		return this.ofsRow, nil
	}
	_pos, err := this._io.Pos()
	if err != nil {
		return 0, err
	}
	tmp216, err := this._parent.Base()
	if err != nil {
		return 0, err
	}
	_, err = this._io.Seek(int64((tmp216 - (6 + (2 * this.RowIndex)))), io.SeekStart)
	if err != nil {
		return 0, err
	}
	tmp217, err := this._io.ReadU2le()
	if err != nil {
		return 0, err
	}
	this.ofsRow = tmp217
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return 0, err
	}
	this._f_ofsRow = true
	this._f_ofsRow = true
	return this.ofsRow, nil
}
